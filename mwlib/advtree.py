"""
The parse tree generated by the parser is a 1:1 representation of the mw-markup.

Unfortunally these trees have some flaws if used to geenerate derived documents.

This module seeks to rebuild the parstree
to be:
 * more locgical markup
 * clean up the parse tree
 * make it more accessible
 * allow for validity checks
 * implement rebuilding strategies

Usefull Documentation:
http://en.wikipedia.org/wiki/Wikipedia:Don%27t_use_line_breaks
http://meta.wikimedia.org/wiki/Help:Advanced_editing


"""
import weakref
import mwlib.parser as parser


def MixIn(pyClass, mixInClass, makeFirst=False):
  if mixInClass not in pyClass.__bases__:
    if makeFirst:
      pyClass.__bases__ = (mixInClass,) + pyClass.__bases__
    else:
      pyClass.__bases__ += (mixInClass,)


class AdvancedNode():
    """
    allows to traverse the tree in any direction and 
    build derived convinience functions
    """
    _parentref = None

    def moveto(self, targetnode, prefix=False):
        """"
        moves this node after target node
        if prefix is true, move in front of target node
        """
        self.parent.removeChild(self)
        tp = targetnode.parent
        idx = tp.children.index(targetnode)
        if not prefix:
            idx+=1
        tp.children = tp.children[:idx] + [self] + tp.children[idx:]
        self._parentref = weakref.ref(tp)
        
    def appendChild(self, c):
        self.children.append(c)
        c._parentref = weakref.ref(self)
        
    def removeChild(self, c):
        self.replaceChild(c, [])

    def replaceChild(self, c, newchildren = []):
        idx = self.children.index(c)
        self.children.remove(c)
        c._parentref = None
        if newchildren:
            self.children = self.children[:idx] + newchildren + self.children[idx:]
            for nc in newchildren:
                nc._parentref = weakref.ref(self)

    def getParents(self):
        if self.parent:
            return self.parent.getParents() + [self.parent]
        else:
            return []

    def getParent(self):
        if not self._parentref:
            return None
        x = self._parentref()
        if not x:
            raise weakref.ReferenceError
        return x

    
    def getClassInParents(self, klass):
        for p in self.parents:
            if p.__class__ == klass:
                return p

    def getSiblings(self):
        return (c for c in self.getAllSiblings() if c!=self)

    def getAllSiblings(self):
        "all siblings plus me my self and i"
        if self.parent:
            return self.parent.children
        return []

    def getPrevious(self):
        "return previous sibling"
        s = self.getAllSiblings()
        try:
            idx = s.index(self)
        except ValueError:
            return None
        if idx -1 <0:
            return None
        else:
            return s[idx-1]

    def getNext(self):
        "return next sibling"
        s = self.getAllSiblings()
        try:
            idx = s.index(self)
        except ValueError:
            return None
        if idx+1 >= len(s):
            return None
        else:
            return s[idx+1]

    def getLast(self):
        "return last sibling"
        s = self.getAllSiblings()
        if s:
            return s[-1]

    def getFirst(self):
        "return first sibling"
        s = self.getAllSiblings()
        if s:
            return s[0]

    def getLastChild(self):
        "return last child of this node"
        if self.children:
            return self.children[-1]

    def getFirstChild(self):
        "return first child of this node"
        if self.children:
            return self.children[0]

    parent = property(getParent)
    parents = property(getParents)
    next = property(getNext)
    previous = property(getPrevious)
    siblings = property(getSiblings)
    last = property(getLast)
    first = property(getFirst)
    lastchild = property(getLastChild)
    firstchild = property(getFirstChild)
    

class InlineNode():
    """
    class indicates that these elements should be inline
    """

class BlockNode():
    """
    class indicates that these elements block 
    """
    
class AdvancedSection(AdvancedNode):
    h_level = 0 # sthis is set if it originates from an H1, H2, ... TagNode
    def getSectionLevel(self):
        return 1 + [p.__class__ for p in self.getParents()].count(self.__class__)
        
    
class Emphasized(parser.Style, AdvancedNode):
    "EM"
    pass

class Strong(parser.Style, AdvancedNode):
    pass

class DefinitionList(parser.Style, AdvancedNode):
    "DL"
    pass

class DefinitionTerm(parser.Style, AdvancedNode):
    "DT"
    pass

class DefinitionDefinition(parser.Style, AdvancedNode):
    "DD"
    pass

class Blockquote(parser.Style, AdvancedNode):
    "margins to left &  right"
    pass

class Indented(parser.Style, AdvancedNode):
    "margin to the left"

class Overline(parser.Style, AdvancedNode):
    _style = "overline"

class Underline(parser.Style, AdvancedNode):
    _style = "underline"

class Sub(parser.Style, AdvancedNode):
    _style = "sub"

class Sup(parser.Style, AdvancedNode):
    _style = "sup"

class Small(parser.Style, AdvancedNode):
    _style = "small"

class Cite(parser.Style, AdvancedNode):
    _style = "cite"


class BreakingReturn(parser.TagNode, AdvancedNode):
    _tag = "code"

class BreakingReturn(parser.TagNode, AdvancedNode):
    _tag = "br"

class HorizontalRule(parser.TagNode, AdvancedNode):
    _tag = "hr"

class Index(parser.TagNode, AdvancedNode):
    _tag = "index"

class Teletyped(parser.TagNode, AdvancedNode):
    _tag = "tt"

class Reference(parser.TagNode, AdvancedNode):
    _tag = "tt"

class Gallery(parser.TagNode, AdvancedNode):
    _tag = "gallery"

class Center(parser.TagNode, AdvancedNode):
    _tag = "center"
    

# collect classes 
tagNodeMap = dict( (k._tag,k) for k in [BreakingReturn, HorizontalRule, Index, Teletyped, Reference, Gallery, Center] )
styleNodeMap = dict( (k._style,k) for k in [Overline, Underline, Sub, Sup, Small, Cite] )

advancedNodes = {"Section": AdvancedSection}
inLineNodes = (parser.Style, parser.Text)


blockNodes = (parser.Book, parser.Chapter, parser.Article, parser.Section, parser.Paragraph, 
              parser.PreFormatted, parser.Cell, parser.Row, parser.Table, parser.Item, 
              parser.ItemList, parser.Timeline, Cite, HorizontalRule, Gallery, Indented, 
              DefinitionList, DefinitionTerm, DefinitionDefinition)

inlineNodes = (parser.URL, parser.NamedURL, parser.Link, parser.CategoryLink, parser.SpecialLink, 
               parser.Text, Index, Teletyped, BreakingReturn, Reference, Strong,Emphasized, 
               Sub, Sup, Small, Underline, Overline)

# hmm, this is global, fixme
for k in blockNodes:
    MixIn(k, BlockNode)

for k in inlineNodes:
    MixIn(k, InlineNode)

"""
not clear what to do
specialNode = [parser.Node, parser.Math, parser.Magic, parser.TagNode, parser.Style, parser.Image ]
Image.isInline()
"""




def fixStyle(node):
    if not node.__class__ == parser.Style:
        return
    # replace this node by a more apporiate
    if node.caption == "''": 
        node.__class__ = Emphasized
        node.caption = ""
    elif node.caption=="'''''":
        node.__class__ = Strong
        node.caption = ""
        em = Emphasized("''")
        em.children = node.children
        node.children = [em]
    elif node.caption == "'''":
        node.__class__ = Strong
        node.caption = ""
    elif node.caption == ";": # this starts a definition list ? DL [DT->DD, ...]
        # check if previous node is DefinitionList, if not create one
        if node.previous.__class__ == DefinitionList:
            node.__class__ = DefinitionTerm
            node.moveto(node.previous.lastchild)
        else:
            node.__class__ = DefinitionList
            dt = DefinitionTerm()
            dt.children = node.children
            node.children = []
            node.appendChild(dt)
    elif node.caption.startswith(":"): 
        if node.previous.__class__ == DefinitionList:
            node.__class__ = DefinitionDefinition
            node.moveto(node.previous.lastchild)
            node.caption = ""
        else:
            node.__class__ = Indented
    elif node.caption in styleNodeMap:
        node.__class__ = styleNodeMap[node.caption]
        node.caption = ""
    else:
        raise Exception, "unknown style %s" % node.caption
    return node




def fixStyles(node):
    if node.__class__ == parser.Style:
        fixStyle(node)
    for c in node.children[:]:
        fixStyles(c)


def removeNodes(node):
    if node.__class__ == parser.Node:
        node.parent.replaceChild(node, node.children)
    for c in node.children[:]:
        removeNodes(c)

def removeNewlines(node):
    """
    remove newlines, tabs, spaces if we are next to a blockNode
    """
    if node.__class__ == parser.Text and node.caption.strip() == u"":
        prev = node.previous or node.parent # previous sibling node or parentnode 
        next = node.next or node.parent.next
        if isinstance(next, BlockNode) or isinstance(prev, BlockNode) :
            node.parent.removeChild(node)    
    for c in node.children[:]:
        removeNewlines(c)

def fixBreakingReturns(node):
    for c in node.children[:]:
        if c.__class__ == BreakingReturn:
            prev = c.previous or c.parent # previous sibling node or parentnode 
            next = c.next or c.parent.next
            if isinstance(next, BlockNode) or isinstance(prev, BlockNode) :
                or isinstance(c.previous or c.parent, BlockNode):
                node.removeChild(c)
        fixBreakingReturns(c)
        

def fixTagNodes(node):
    for c in node.children:
        if c.__class__ == parser.TagNode:
            if c.caption in tagNodeMap:
                c.__class__ = tagNodeMap[c.caption]
            elif c.caption in ("h1", "h2", "h3", "h4", "h5", "h6"):
                c.__class__ = parser.Section 
                MixIn(c.__class__, AdvancedSection)
                c._h_level = int(c.caption[1])
                c.caption = ""
            else:
                print "unknowntagnode", c
                raise Exception, "unknown tag %s" % c.caption
        fixTagNodes(c)


def extendClasses(node):
    MixIn(node.__class__, advancedNodes.get(node.__class__.__name__, AdvancedNode))
    for c in node.children[:]:
        extendClasses(c)
        c._parentref = weakref.ref(node)            


def buildAdvancedTree(root):
    extendClasses(root) 
    fixTagNodes(root)
    removeNodes(root)
    removeNewlines(root)
    fixStyles(root)
    fixBreakingReturns(root)


def test():
    pass


def main():
    import sys
    import parser
    from mwlib.dummydb import DummyDB
    import xhtmlwriter
    db = DummyDB()
    
    from mwlib.dummydb import DummyDB
    from mwlib.uparser import parseString
    db = DummyDB()
    
    for x in sys.argv[1:]:
        input = unicode(open(x).read(), 'utf8')
        r = parseString(title=x, raw=input, wikidb=db)
        #parser.show(sys.stderr, r, 0)
        buildAdvancedTree(r)
        parser.show(sys.stderr, r, 0)
        
        dbw = xhtmlwriter.MWXHTMLWriter()
        dbw.write(r)
        xhtmlwriter.indent(dbw.root)
        print dbw.asstring()
        


if __name__=="__main__":
    main()


"""
build convinience functions for volker

 is TAG in parents
 rebuild tables
 rebuild unordered lists

make it easy to express rules!

make node move operations easy (we had problems!!!)

"""
